window.define(['js/book',
               'js/notifications',
               'js/urlutils'
               ],
function(Book, Notifications, UrlUtils) {

"use strict";

/**
 * This module uses a database with the following structure.
 *
 * Name: "openberg:library"
 * Stores:
 *  books: {
 *   id (primary key, number, autogenerated),
 *   title (string, indexed),
 *   author (string, indexed),
 *   file (Blob),
 *   cover (Blob | null),
 *  },
 */

/**
 * A manager for a collection of books.
 *
 * @param {Array} openers A list of filters for opening books.
 */
function Library(openers) {
  if (!Array.isArray(openers)) {
    throw new TypeError("Expected an array of book openers");
  }
  /**
   * Instances of Library notify of the following events:
   * - library:open:success ({entry: Entry}) A file has been picked.
   * - file:nopicker (null) Could not pick a file, generally
   *    because no file picker has been installed.
   */
  this.notifications = new Notifications([
    "library:open:success",
    "library:open:failure",
    "library:update:newbook",
  ]);

  this._openers = openers;

  this._promiseInitialized = null;
  this._db = null;

  /**
   * The entries in the library.
   *
   * @type{Array<Library.Entry}
   */
  this._entries = [
    new Entry(this, "Welcome to Lector", "The OpenBerg team", UrlUtils.toURL("samples/lector.epub")),
    new Entry(this, "Alice in Wonderland", "Lewis Caroll", UrlUtils.toURL("samples/alice.epub")),
    new Entry(this, "1984", "George Orwell", UrlUtils.toURL("samples/1984.epub")),
  ];
}
Library.prototype = {
  /**
   * Initialize the library.
   *
   * @return {Promise}
   */
  init: function() {
    if (this._promiseInitialized) {
      console.log("Library", "init", "initialization already started");
      return this._promiseInitialized;
    }
    console.log("Library", "init", "starting");
    return this._promiseInitialized = this._init();
  },
  /**
   * Implementation of `init()`
   *
   * Open the database, load the books, populate `this._entries`.
   */
  _init: function() {
    var promise = new Promise((resolve, reject) => {
      console.log("Library", "_init", "attempting to open db");
      var request = window.indexedDB.open("openberg:library", /* version */ 2);

      request.onupgradeneeded = event => {
        // This is the first time we open the datbase, or we have changed
        // the database schema. Create the object store and its indices.
        console.log("Library", "_init", "onupgradeneeded", event);
        var db = event.target.result;
        var store = db.createObjectStore("books", {
          keyPath: "id",
          autoIncrement: true
        });
        store.createIndex("byAuthor", "author", {
          unique: false,
        });
        store.createIndex("byTitle", "title", {
          unique: false,
        });
      };
      request.onsuccess = event => {
        console.log("Library", "_init", "onsuccess", event);
        resolve((this._db = event.target.result));
      };
      request.onerror = reject;
    });
    promise = promise.then(db =>
      new Promise((resolve, reject) => {
        var transaction = db.transaction(["books"], "readonly");
        var books = transaction.objectStore("books");
        var request = books.openCursor();
        request.onerror = reject;
        request.onsuccess = event => {
          var cursor = event.target.result;
          if (!cursor) {
            console.log("Library", "_init", "cursor", "done iterating");
            return;
          }
          var {id, title, author, file} = cursor.value;
          console.log("Library", "_init", "iterating", id, title, author);
          this._entries.push(new Entry(this, title, author, file));
          cursor.continue();
        };
        transaction.oncomplete = resolve;
      })
    );
    promise = promise.then(() => {
      console.log("Library", "_init", "complete");
    }, error => {
      console.error("Library", "_init", error);
    });
    return promise;
  },

  /**
   * Entries for all books currently in the library.
   */
  get entries() {
    return this._entries;
  },

  /**
   * Open a book from a source.
   *
   * @return {Promise<Book>} A book, already initialized.
   */
  open: function(source) {
    var promise = this.init();
    promise = promise.then(() => {
      var entry = new Entry(this, null, null, source);
      return entry.open();
    });
    promise = promise.then(book => {
      this._import(book, source); // Don't wait
      return book;
    });
    return promise;
  },

  /**
   * Import a book to the database, downloading it first if necessary.
   *
   * This method notifies `library:update:newbook` once the book is available.
   *
   * @param {Book} book Information on the book.
   * @param {URL|string|File|Blob} source The binary data for the book.
   *
   * @return {Promise} A promise fulfilled once the book is entirely written
   * to the database.
   */
  _import: function(book, source) {
    if (!(book instanceof Book)) {
      throw new TypeError("Expected a book, got " + book);
    }
    if (source instanceof URL || typeof source == "string") {
      console.log("Library", "_import", "We need to download the book from", source);
      var promise = UrlUtils.download(source);
      promise = promise.then(data =>
        this._import(book, data)
      );
      return promise;
    }
    if (source instanceof File || source instanceof Blob) {
      var transaction = this._db.transaction(["books"], "readwrite");
      var books = transaction.objectStore("books");
      var book = {
        title: book.title || "?",
        author: book.author || "?",
        file: source,
        cover: null,
      };
      return new Promise((resolve, reject) => {
        var request = books.add(book);
        request.onsuccess = (event) => {
          console.log("Library", "_import", "books.add", event);
          var entry = new Entry(this, book.title, book.author, event.id);
          this._entries.push(entry);
          this.notifications.notify("library:update:newbook", {
            entry: entry
          });
        };
        request.onerror = reject;
        transaction.oncomplete = resolve;
      });
    } else {
      throw new TypeError("Expected URL, string, File or Blob, got " + source);
    }
  }
};

/**
 * An entry in the library.
 *
 * This entry can provide the title and author of a book,
 * without having to open the book first. Future versions
 * will also provide access to the database.
 *
 * @param {Library} library The owning library.
 * @param {string|null} title The title of the book, or `null`
 * if we do not know the title yet.
 * @param {string|null} author The author of the book, or `null`
 * if we do not know the author yet.
 * @param {URL|File} source Information on where to load the book.
 * This argument a URL for books that are provided with the software,
 * File for books picked using the file picker.
 */
function Entry(library, title, author, source) {
  console.log("Library.Entry", "constructor", source);
  this._title = title;
  this._author = author;
  this._source = source;
  this._library = library;
};
Entry.prototype = {
  /**
   * Open the book.
   *
   * @return {Promise<Book>}
   */
  open: function() {
    console.log("Library.Entry", "open", this._title, this._author, this._source);

    var promise = Promise.resolve();
    promise = promise.then(() => {
      console.log("Library.Entry", "open", "in progress");
      return Book.open(this._source, this._library._openers);
    })
    promise = promise.then(book => {
      console.log("Library.Entry", "open", "book opened");
      return book.init().then(() => book);
    });
    promise = promise.then(book => {
      console.log("Library.Entry", "open", "book initialized");
      this._title = book.title;
      this._author = book.author;
      this._library.notifications.notify("library:open:success", {
        entry: this,
      });
      return book;
    });
    promise = promise.then(null, error => {
      console.error("Library.Entry", "open", error);
      this._library.notifications.notify("library:open:failure", {
        entry: this,
        error: error,
      });
      throw error;
    });
    return promise;
  },
  /**
   * The title of the book.
   *
   * @type{string|null}
   */
  get title() {
    return this._title;
  },
  /**
   * The author of the book.
   *
   * @type{string|null}
   */
  get author() {
    return this._author;
  }
};

return Library;

});
